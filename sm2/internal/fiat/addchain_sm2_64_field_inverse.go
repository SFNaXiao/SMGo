// Copyright 2021 bilibili. All rights reserved. Author: Guo, Weiji guoweiji@bilibili.com
// 哔哩哔哩版权所有 2021。作者：郭伟基 guoweiji@bilibili.com
// 代码为使用addchain工具自动生成，勿编辑
//    addchain search "2^256 - 2^224 - 2^96 + 2^64 - 1 - 2" >sm2_field.ac
//    addchain gen -tmpl template_field.tmpl sm2_field.ac > ../fiat/addchain_sm2_64_field_inverse.go
//
// addchain项目的网络地址为：https://github.com/mmcloughlin/addchain
//
// 背景介绍：
// 素域求逆问题，在考虑安全性的时候，为了避免算法运行时间泄漏私钥信息（例如，SM2的签名算法要求计算d ^ -1），有一种常数时间算法是利用费马小定理：
//    a ^ (p-1) = 1 mod p  其中 a 不是 p 的倍数，而 p 为素数
// 可以得知：
//    a ^ (p-2) 为 a 在 Fp上的乘法逆元。
// 在计算SM2的标量域（mod n）的时候，由于n是固定的，因此可以通过一个对n较为优化的addition chain分解，给出优化的模指数算法去计算 a ^ (n - 2)
// 而addchain (addition chain) 工具能够计算给定素数的较优化的连加链
//
// 相对于通常的EEA算法（一般在大整数类里面实现，无针对性优化），使用费马小定理求逆的代价大约是EEA的两倍。
// 参考: Computing Multiplicative Inverses in GFp (1969, by George E. Collins)
//
// 叠加addchain优化后，可能缩小一部分差距，大约在20% ～ 30%左右。
//
// 具体性能对比需要运行测试

package fiat

// Invert an element in the SM2 curve field (mod p).
// Output: z = 1/x mod (SM2 p) if x != 0, and 0 otherwise
func sm2FermatInvert_FiatAC(z *sm2MontgomeryDomainFieldElement, x *sm2MontgomeryDomainFieldElement)  {
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_110     = 2*_11
	//	_111     = 1 + _110
	//	_111000  = _111 << 3
	//	_111111  = _111 + _111000
	//	_1111110 = 2*_111111
	//	_1111111 = 1 + _1111110
	//	x12      = _1111110 << 5 + _111111
	//	x24      = x12 << 12 + x12
	//	x31      = x24 << 7 + _1111111
	//	i39      = x31 << 2
	//	i68      = i39 << 29
	//	x62      = x31 + i68
	//	i71      = i68 << 2
	//	x64      = i39 + i71 + _11
	//	i265     = ((i71 << 32 + x64) << 64 + x64) << 94
	//	return     (x62 + i265) << 2 + 1
	//
	// Operations: 255 squares 14 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
		var (
			t0 = new(sm2MontgomeryDomainFieldElement)
			t1 = new(sm2MontgomeryDomainFieldElement)
			t2 = new(sm2MontgomeryDomainFieldElement))

		
		// Step 1: z = x^0x2
		sm2Square(z, x)
		
		// Step 2: t0 = x^0x3
		sm2Mul(t0, x, z)
		
		// Step 3: z = x^0x6
		sm2Square(z, t0)
		
		// Step 4: z = x^0x7
		sm2Mul(z, x, z)
		
		// Step 7: t1 = x^0x38
		sm2Square(t1, z)
		for s := 1; s < 3; s++ {
			sm2Square(t1, t1)
		}
		
		// Step 8: t1 = x^0x3f
		sm2Mul(t1, z, t1)
		
		// Step 9: t2 = x^0x7e
		sm2Square(t2, t1)
		
		// Step 10: z = x^0x7f
		sm2Mul(z, x, t2)
		
		// Step 15: t2 = x^0xfc0
		for s := 0; s < 5; s++ {
			sm2Square(t2, t2)
		}
		
		// Step 16: t1 = x^0xfff
		sm2Mul(t1, t1, t2)
		
		// Step 28: t2 = x^0xfff000
		sm2Square(t2, t1)
		for s := 1; s < 12; s++ {
			sm2Square(t2, t2)
		}
		
		// Step 29: t1 = x^0xffffff
		sm2Mul(t1, t1, t2)
		
		// Step 36: t1 = x^0x7fffff80
		for s := 0; s < 7; s++ {
			sm2Square(t1, t1)
		}
		
		// Step 37: z = x^0x7fffffff
		sm2Mul(z, z, t1)
		
		// Step 39: t2 = x^0x1fffffffc
		sm2Square(t2, z)
		for s := 1; s < 2; s++ {
			sm2Square(t2, t2)
		}
		
		// Step 68: t1 = x^0x3fffffff80000000
		sm2Square(t1, t2)
		for s := 1; s < 29; s++ {
			sm2Square(t1, t1)
		}
		
		// Step 69: z = x^0x3fffffffffffffff
		sm2Mul(z, z, t1)
		
		// Step 71: t1 = x^0xfffffffe00000000
		for s := 0; s < 2; s++ {
			sm2Square(t1, t1)
		}
		
		// Step 72: t2 = x^0xfffffffffffffffc
		sm2Mul(t2, t2, t1)
		
		// Step 73: t0 = x^0xffffffffffffffff
		sm2Mul(t0, t0, t2)
		
		// Step 105: t1 = x^0xfffffffe0000000000000000
		for s := 0; s < 32; s++ {
			sm2Square(t1, t1)
		}
		
		// Step 106: t1 = x^0xfffffffeffffffffffffffff
		sm2Mul(t1, t0, t1)
		
		// Step 170: t1 = x^0xfffffffeffffffffffffffff0000000000000000
		for s := 0; s < 64; s++ {
			sm2Square(t1, t1)
		}
		
		// Step 171: t0 = x^0xfffffffeffffffffffffffffffffffffffffffff
		sm2Mul(t0, t0, t1)
		
		// Step 265: t0 = x^0x3fffffffbfffffffffffffffffffffffffffffffc00000000000000000000000
		for s := 0; s < 94; s++ {
			sm2Square(t0, t0)
		}
		
		// Step 266: z = x^0x3fffffffbfffffffffffffffffffffffffffffffc00000003fffffffffffffff
		sm2Mul(z, z, t0)
		
		// Step 268: z = x^0xfffffffeffffffffffffffffffffffffffffffff00000000fffffffffffffffc
		for s := 0; s < 2; s++ {
			sm2Square(z, z)
		}
		
		// Step 269: z = x^0xfffffffeffffffffffffffffffffffffffffffff00000000fffffffffffffffd
		sm2Mul(z, x, z)
		
	}
