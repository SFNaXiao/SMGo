// modified based on generated file from the standard library of the go project by crypto/elliptic/internal/fiat/generate.go
// 基于go语言标准库crypto/elliptic/internal/fiat/generate.go所生成的文件修改
// 原版权声明如下：

// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by generate.go. DO NOT EDIT.

package fiat

import (
	"crypto/subtle"
	"errors"
	"math/big"
)

// SM2ScalarElement is an integer modulo n (0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123).
//
// The zero value is a valid zero element.
type SM2ScalarElement struct {
	// Values are represented internally always in the Montgomery domain, and
	// converted in Bytes and SetBytes.
	x sm2ScalarMontgomeryDomainFieldElement
}

const SM2ScalarElementLen = 32

type sm2ScalarUntypedFieldElement = [4]uint64

// One sets e = 1, and returns e.
func (e *SM2ScalarElement) One() *SM2ScalarElement {
	sm2ScalarSetOne(&e.x)
	return e
}

// Equal returns 1 if e == t, and zero otherwise.
func (e *SM2ScalarElement) Equal(t *SM2ScalarElement) int {
	eBytes := e.Bytes()
	tBytes := t.Bytes()
	return subtle.ConstantTimeCompare(eBytes, tBytes)
}

var sm2ScalarZeroEncoding = new(SM2ScalarElement).Bytes()

// IsZero returns 1 if e == 0, and zero otherwise.
func (e *SM2ScalarElement) IsZero() int {
	eBytes := e.Bytes()
	return subtle.ConstantTimeCompare(eBytes, sm2ScalarZeroEncoding)
}

// Set sets e = t, and returns e.
func (e *SM2ScalarElement) Set(t *SM2ScalarElement) *SM2ScalarElement {
	e.x = t.x
	return e
}

// Bytes returns the 32-byte big-endian encoding of e.
func (e *SM2ScalarElement) Bytes() []byte {
	// This function is outlined to make the allocations inline in the caller
	// rather than happen on the heap.
	var out [SM2ScalarElementLen]byte
	return e.bytes(&out)
}

func (e *SM2ScalarElement) bytes(out *[SM2ScalarElementLen]byte) []byte {
	var tmp sm2ScalarNonMontgomeryDomainFieldElement
	sm2ScalarFromMontgomery(&tmp, &e.x)
	sm2ScalarToBytes(out, (*sm2ScalarUntypedFieldElement)(&tmp))
	sm2ScalarInvertEndianness(out[:])
	return out[:]
}

func (e *SM2ScalarElement) ToBigInt() *big.Int {
	bytes := e.Bytes()
	return new (big.Int).SetBytes(bytes)
}

// sm2ScalarMinusOneEncoding is the encoding of -1 mod n, so n - 1, the
// highest canonical encoding. It is used by SetBytes to check for non-canonical
// encodings such as n + k, 2n + k, etc.
var sm2ScalarMinusOneEncoding = new(SM2ScalarElement).Sub(
	new(SM2ScalarElement), new(SM2ScalarElement).One()).Bytes()

// SetBytes sets e = v, where v is a big-endian 32-byte encoding, and returns e.
// If v is not 32 bytes or it encodes a value higher than n (0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123),
// SetBytes returns nil and an error, and e is unchanged.
func (e *SM2ScalarElement) SetBytes(v []byte) (*SM2ScalarElement, error) {
	if len(v) != SM2ScalarElementLen {
		return nil, errors.New("invalid SM2ScalarElement encoding")
	}
	for i := range v {
		if v[i] < sm2ScalarMinusOneEncoding[i] {
			break
		}
		if v[i] > sm2ScalarMinusOneEncoding[i] {
			return nil, errors.New("invalid SM2ScalarElement encoding")
		}
	}
	var in [SM2ScalarElementLen]byte
	copy(in[:], v)
	sm2ScalarInvertEndianness(in[:])
	var tmp sm2ScalarNonMontgomeryDomainFieldElement
	sm2ScalarFromBytes((*sm2ScalarUntypedFieldElement)(&tmp), &in)
	sm2ScalarToMontgomery(&e.x, &tmp)
	return e, nil
}

// Add sets e = t1 + t2, and returns e.
func (e *SM2ScalarElement) Add(t1, t2 *SM2ScalarElement) *SM2ScalarElement {
	sm2ScalarAdd(&e.x, &t1.x, &t2.x)
	return e
}

// Sub sets e = t1 - t2, and returns e.
func (e *SM2ScalarElement) Sub(t1, t2 *SM2ScalarElement) *SM2ScalarElement {
	sm2ScalarSub(&e.x, &t1.x, &t2.x)
	return e
}

// Mul sets e = t1 * t2, and returns e.
func (e *SM2ScalarElement) Mul(t1, t2 *SM2ScalarElement) *SM2ScalarElement {
	sm2ScalarMul(&e.x, &t1.x, &t2.x)
	return e
}

// Square sets e = t * t, and returns e.
func (e *SM2ScalarElement) Square(t *SM2ScalarElement) *SM2ScalarElement {
	sm2ScalarSquare(&e.x, &t.x)
	return e
}

// Select sets v to a if cond == 1, and to b if cond == 0.
func (v *SM2ScalarElement) Select(a, b *SM2ScalarElement, cond int) *SM2ScalarElement {
	sm2ScalarSelectznz((*sm2ScalarUntypedFieldElement)(&v.x), sm2ScalarUint1(cond),
		(*sm2ScalarUntypedFieldElement)(&b.x), (*sm2ScalarUntypedFieldElement)(&a.x))
	return v
}

func (z *SM2ScalarElement) Invert(x *SM2ScalarElement) *SM2ScalarElement {
	sm2ScalarFermatInvert_FiatAC(&z.x, &x.x)
	return z
}

func sm2ScalarInvertEndianness(v []byte) {
	for i := 0; i < len(v)/2; i++ {
		v[i], v[len(v)-1-i] = v[len(v)-1-i], v[i]
	}
}

