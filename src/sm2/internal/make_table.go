// Copyright 2021 bilibili. All rights reserved. Author: Guo, Weiji guoweiji@bilibili.com
// 哔哩哔哩版权所有 2021。作者：郭伟基 guoweiji@bilibili.com

//go:build ignore

// You must build this app with custom build tag tablegen

package main

import (
	"bytes"
	"fmt"
	"math/big"
	"os"
	"reflect"
	"smgo/sm2/internal"
)

func main() {
	buf := new(bytes.Buffer)
	writeHeader(buf)
	writeTable(buf,4, 2, 32, 0)
	writeTable(buf,6, 3, 14, 4)
	writeTable(buf,5, 3, 17, 1)

	err := os.WriteFile("sm2/internal/sm2_tables.go", buf.Bytes(), 0644)
	if err != nil {
		panic(err.Error())
	}
}

func writeHeader(buf *bytes.Buffer) {
	const fileHeader = `// Copyright 2021 bilibili. All rights reserved. Author: Guo, Weiji guoweiji@bilibili.com
// 哔哩哔哩版权所有 2021。作者：郭伟基 guoweiji@bilibili.com
//
// This file is generated by make_table.go.
// Base point pre computation
// --------------------------
//
// Take 6-3-14-4 as example: 
// --begin example--
//
// The first table is organized in 3 (subTableCount) sub-tables of 63 points (2^6 -1) (window), 
// with first one looks what follows, in which G* = [2^4]G: (remainder), 42 = 3 x 14
//
// index | bits    | point
// ------+---------+------------------------------
//     1 | 0 0 0 0 0 1 | [1]G*
//     2 | 0 0 0 0 1 0 | [2^42]G*
//    ...
//    63 | 1 1 1 1 1 1 | [2^210 + 2^168 + 2^126 + 2^84 + 2^42 + 1]G*
// ------+---------+------------------------------
// The second sub table is the elements in the first multiplied by 2^14.
// The third sub table, by 2^28
//
// The second table contains 15 elements, that is, G, 2G, ..., 15G. (If remainder is 0
// or 1 then the second table could be omitted.)
//
// The base multiplication algorithm should run 14 iterations. 
// -- end example--
//
// All table elements should be accessed in constant time and in a 
// fashion that leaks no caching information.

package internal

`
	fmt.Fprintln(buf, fileHeader)
}

func writeTable(buf *bytes.Buffer, window, subTableCount, iterations, remainder int) {
	const commentProto = `// We split 256 bits into two tables: the first table serves the upper %d bits 
// (left most), and the second table serves the lower %d bits (right most).
// 256 = %d x %d x %d + %d`
	comment := fmt.Sprintf(commentProto, window * subTableCount * iterations, remainder,
		window, subTableCount, iterations, remainder)
	fmt.Fprintln(buf, comment)

	const tableLineProto = "var sm2Precomputed_%d_%d_%d = [][]*SM2Point {"
	tableWidth := int(raiseToPower2(window).Int64()) - 1
	tableLine := fmt.Sprintf(tableLineProto, window, subTableCount, iterations)
	fmt.Fprintln(buf, tableLine)
	fmt.Printf("generating table %s\n", tableLine)

	var subTables [][]*internal.SM2Point = make([][]*internal.SM2Point, subTableCount)
	for i:=0; i<subTableCount; i++ {
		subTables[i] = make([]*internal.SM2Point, tableWidth)
	}

	fmt.Print("generating g* point...")
	var basics []*internal.SM2Point = make([]*internal.SM2Point, window)
	gStar := internal.NewSM2Generator()
	for i:=1; i<=remainder; i++ {
		gStar.Double(gStar)
		fmt.Print("d")
	}

	fmt.Printf("\nverifying g*\n")
	gStarExpected := intPower2Mult(internal.NewSM2Generator(), remainder)
	if !reflect.DeepEqual(gStar.Bytes(), gStarExpected.Bytes()) {
		panic("g* generated incorrectly")
	}

	fmt.Println("generating lookup table")
	basics[0] = gStar
	for i:=1; i<window; i++ {
		basics[i] = intPower2Mult(gStar, subTableCount * iterations * i)
	}

	fmt.Println("filling first sub table")
	subTables[0][0] = gStar
	for i:=1; i<tableWidth; i++ {
		p := internal.NewSM2Point()
		b := i+1

		fmt.Printf("filling element #%d, ", i)
		for j:=0; j<window && b!=0; j++ {
			if b & 1 == 1 {
				p.Add(p, basics[j])
				fmt.Printf("+basics[%d],", j)
			}
			b >>= 1
		}
		fmt.Println("...done")

		subTables[0][i] = p
	}

	for i:=1; i<subTableCount; i++ {
		fmt.Printf("generating sub table %d with first sub table's element multiplied by 2^%d\n", i+1, i*iterations)
		for j:=0; j<tableWidth; j++ {
			subTables[i][j] = intPower2Mult(subTables[0][j], i*iterations)
		}
	}

	for i:=0; i<subTableCount; i++ {
		fmt.Fprintf(buf,"\t{\n\t\t//sub table #%d\n", i+1)

		writeSubTable(buf, subTables[i])

		fmt.Fprintln(buf, "\t},")
	}

	fmt.Fprintln(buf,"}\n") // close the table

	if remainder > 1 { // generate second table
		const secondTableLineProto = "var sm2Precomputed_%d_%d_%d_Remainder = []*SM2Point {"
		secondTableLine := fmt.Sprintf(secondTableLineProto, window, subTableCount, iterations)
		fmt.Fprintln(buf, secondTableLine)

		writePoint(buf, internal.NewSM2Generator())

		power := int(raiseToPower2(remainder).Int64())
		for i:=2; i<power; i++ {
			p := intMult(internal.NewSM2Generator(), big.NewInt(int64(i)))
			writePoint(buf, p)
		}

		fmt.Fprintln(buf,"}\n") // close the table
	}
}

func intPower2Mult(p *internal.SM2Point, exp int) *internal.SM2Point {
	power := new (big.Int).Lsh(big.NewInt(1), uint(exp))
	return intMult(p, power)
}

func intMult(p *internal.SM2Point, power *big.Int) *internal.SM2Point {
	powerBytes := power.Bytes()

	ret, err := internal.ScalarMult_Unsafe_DaA(p, &powerBytes)
	if err != nil {
		panic(err.Error())
	}

	return ret
}

func raiseToPower2(exp int) *big.Int {
	return new(big.Int).Exp(big.NewInt(2), big.NewInt(int64(exp)), nil)
}

func writeSubTable(buf *bytes.Buffer, subTable []*internal.SM2Point) {
	for _, p := range subTable {
		writePoint(buf, p)
	}
}

func writePoint(buf *bytes.Buffer, p *internal.SM2Point) {
	x, y := p.ToMontgomeryAffine()
	xx, yy := [4]uint64(x.GetRaw()), [4]uint64(y.GetRaw())
	fmt.Fprintf(buf,"\t\tFromMontgomery([4]uint64{%d, %d, %d, %d}, [4]uint64{%d, %d, %d, %d}),\n",
		xx[0], xx[1], xx[2], xx[3], yy[0], yy[1], yy[2], yy[3])
}