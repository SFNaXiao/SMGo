// Copyright 2021 bilibili. All rights reserved. Author: Guo, Weiji guoweiji@bilibili.com
// 哔哩哔哩版权所有 2021。作者：郭伟基 guoweiji@bilibili.com
// 代码为使用addchain工具自动生成，勿编辑
//    addchain search "115792089210356248756420345214020892766061623724957744567843809356293439045923 - 2" > sm2_scalar.ac
//    addchain gen -tmpl template_scalar.tmpl sm2_scalar.ac > ../fiat/addchain_sm2_64_scalar_inverse.go
//
// addchain项目的网络地址为：https://github.com/mmcloughlin/addchain
//
// 背景介绍：
// 素域求逆问题，在考虑安全性的时候，为了避免算法运行时间泄漏私钥信息（例如，SM2的签名算法要求计算d ^ -1），有一种常数时间算法是利用费马小定理：
//    a ^ (p-1) = 1 mod p  其中 a 不是 p 的倍数，而 p 为素数
// 可以得知：
//    a ^ (p-2) 为 a 在 Fp上的乘法逆元。
// 在计算SM2的标量域（mod n）的时候，由于n是固定的，因此可以通过一个对n较为优化的addition chain分解，给出优化的模指数算法去计算 a ^ (n - 2)
// 而addchain (addition chain) 工具能够计算给定素数的较优化的连加链
//
// 相对于通常的EEA算法（一般在大整数类里面实现，无针对性优化），使用费马小定理求逆的代价大约是EEA的两倍。
// 参考: Computing Multiplicative Inverses in GFp (1969, by George E. Collins)
//
// 叠加addchain优化后，可能缩小一部分差距，大约在20% ～ 30%左右。
//
// 具体性能对比需要运行测试

package fiat

// Invert an element in the SM2 scalar field (mod n). Note: this is NOT a SM2 Curve Field inversion (mod p).
// Output: z = 1/x mod (SM2 n) if x != 0, and 0 otherwise
func sm2ScalarFermatInvert_FiatAC(z *sm2ScalarMontgomeryDomainFieldElement, x *sm2ScalarMontgomeryDomainFieldElement) {
	//
	{{- range lines (format .Script) }}
	//	{{ . }}
	{{- end }}
	//
	// Operations: {{ .Ops.Doubles }} squares {{ .Ops.Adds }} multiplies
	//
	// Generated by {{ .Meta.Module }} {{ .Meta.ReleaseTag }}.

	// Allocate Temporaries.
		var (
			{{- range .Program.Temporaries }}
			{{ . }} = new(sm2ScalarMontgomeryDomainFieldElement)
			{{- end -}}
		)

		{{ range $i := .Program.Instructions }}
		// {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
		{{- with add $i.Op }}
		sm2ScalarMul({{ $i.Output }}, {{ .X }}, {{ .Y }})
		{{ end -}}

		{{- with double $i.Op }}
		sm2ScalarSquare({{ $i.Output }}, {{ .X }})
		{{ end -}}

		{{- with shift $i.Op -}}
		{{- $first := 0 -}}
		{{- if ne $i.Output.Identifier .X.Identifier }}
		sm2ScalarSquare({{ $i.Output }}, {{ .X }})
		{{- $first = 1 -}}
		{{- end }}
		for s := {{ $first }}; s < {{ .S }}; s++ {
			sm2ScalarSquare({{ $i.Output }}, {{ $i.Output }})
		}
		{{ end -}}
		{{- end }}
	}
